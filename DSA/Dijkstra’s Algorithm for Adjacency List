◆ Dijkstra’s Algorithm for Adjacency List

→ Dijkstra's Algorithm can be defined as a algorithm that is used for finding the shortest distance, or path, from the starting node to target node in a weighted graph.
→ This Algorithm basically makes a tree of the shortest path from the starting node, the source, to all other nodes (points) in the graph.

• Let's suppose There's a graph given G(V,E) with its adjacency list representation, and a source vertex is also provided. Then At that time, Dijkstra’s algorithm is used to find the minimum shortest path between source vertex to any other vertex of the graph G.

► In order to solve this problem, We will use two Lists :-
 1. One is to store vertices which have been considered as the shortest path tree.
 2. Other one is to hold vertices which aren't considered yet.
 
→ We will find the unconsidered vertex, which has the minimum distance from the source in each phase of the Algorithm.
→ In order to find the path from Source and Destination, we will use "Predecessor Node".
 
 The Complexity of Dijkstra's shortest path algorithm is O(E log V) as the graph is represented using adjacency list. Here the E is the number of edges, and V is Number of vertices.
    ALGORITHM - dijkstraShortestPath(g : Graph, dist, prev, start : node)
    
⪼ Applications of Dijkstra's Algorithm :-
1. For Telephonic Networks
2. For Map Applications
3. Let's see one example like, We want to travel from Pune to Mumbai then There were severals pathways which we can follow but we will be more looking forward towards the least possible time-consuming path-ways. This can be defined as "Dijkstra's Algorithm.

⪼ Now Let's see one code example explaining the Dijkstra's Algorithm :-

#include<iostream>
#include<set>
#include<list>
#include<algorithm>
using namespace std;

typedef struct nodes {
   int dest;
   int cost;
}node;

class Graph {
   int n;
   list<node> *adjList;
   private:
      void showList(int src, list<node> lt) {
         list<node> :: iterator i;
         node tempNode;

         for(i = lt.begin(); i != lt.end(); i++) {
            tempNode = *i;
            cout << "(" << src << ")---("<<tempNode.dest << "|"<<tempNode.cost<<") ";
         }
         cout << endl;
      }
   public:
      Graph() {
         n = 0;
      }

      Graph(int nodeCount) {
         n = nodeCount;
         adjList = new list<node>[n];
      }

      void addEdge(int source, int dest, int cost) {
         node newNode;
         newNode.dest = dest;
         newNode.cost = cost;
         adjList[source].push_back(newNode);
      }

      void displayEdges() {
         for(int i = 0; i<n; i++) {
            list<node> tempList = adjList[i];
            showList(i, tempList);
         }
      }

      friend void dijkstra(Graph g, int *dist, int *prev, int start);
};

void dijkstra(Graph g, int *dist, int *prev, int start) {
   int n = g.n;

   for(int u = 0; u<n; u++) {
      dist[u] = 9999;   //set as infinity
      prev[u] = -1;    //undefined previous
   }

   dist[start] = 0;   //distance of start is 0
   set<int> S;       //create empty set S
   list<int> Q;

   for(int u = 0; u<n; u++) {
      Q.push_back(u);    //add each node into queue
   }

   while(!Q.empty()) {
      list<int> :: iterator i;
      i = min_element(Q.begin(), Q.end());
      int u = *i; //the minimum element from queue
      Q.remove(u);
      S.insert(u); //add u in the set
      list<node> :: iterator it;

      for(it = g.adjList[u].begin(); it != g.adjList[u].end();it++) {
         if((dist[u]+(it->cost)) < dist[it->dest]) { //relax (u,v)
            dist[it->dest] = (dist[u]+(it->cost));
            prev[it->dest] = u;
         }
      }
   }
}

main() {
   int n = 7;
   Graph g(n);
   int dist[n], prev[n];
   int start = 0;

   g.addEdge(0, 1, 3);
   g.addEdge(0, 2, 6);
   g.addEdge(1, 0, 3);
   g.addEdge(1, 2, 2);
   g.addEdge(1, 3, 1);
   g.addEdge(2, 1, 6);
   g.addEdge(2, 1, 2);
   g.addEdge(2, 3, 1);
   g.addEdge(2, 4, 4);

   g.addEdge(2, 5, 2);
   g.addEdge(3, 1, 1);
   g.addEdge(3, 2, 1);
   g.addEdge(3, 4, 2);
   g.addEdge(3, 6, 4);
   g.addEdge(4, 2, 4);
   g.addEdge(4, 3, 2);
   g.addEdge(4, 5, 2);
   g.addEdge(4, 6, 1);
   g.addEdge(5, 2, 2);
   g.addEdge(5, 4, 2);
   g.addEdge(5, 6, 1);
   g.addEdge(6, 3, 4);
   g.addEdge(6, 4, 1);
   g.addEdge(6, 5, 1);

   dijkstra(g, dist, prev, start);

   for(int i = 0; i<n; i++)
      if(i != start)
         cout<<start<<" to "<<i<<", Cost: "<<dist[i]<<" Previous: "<<prev[i]<<endl;
}
